#!/usr/bin/env python
#
# Copyright 2019 DFKI GmbH.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the
# following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
# NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
# USE OR OTHER DEALINGS IN THE SOFTWARE.
import numpy as np
import json
from copy import copy
from anim_utils.utilities.log import write_log, write_message_to_log, LOG_MODE_DEBUG, LOG_MODE_ERROR, LOG_MODE_INFO
from .utils import _transform_point_from_cad_to_opengl_cs
from .constants import *
from .trajectory_constraint_reader import TrajectoryConstraintReader
from .keyframe_constraint_reader import KeyframeConstraintReader


class MGInputFormatReader(object):
    """Implements functions used for the processing of the constraints from the input file
    generated by CNL processing.

    Parameters
    ----------
    * mg_input_file : file path or json data read from a file
        Contains elementary action list with constraints, start pose and keyframe annotations.
    """
    def __init__(self, motion_state_graph, activate_joint_mapping=False, activate_coordinate_transform=True, scale_factor=1.0):
        self.motion_state_graph = motion_state_graph
        self.mg_input_file = None
        self.action_list = list()
        self.keyframe_annotations = list()
        self.joint_name_map = dict()
        self.inverse_joint_name_map = dict()
        self._fill_joint_name_map()
        self.activate_joint_mapping = activate_joint_mapping
        self.activate_coordinate_transform = activate_coordinate_transform
        self.scale_factor = scale_factor
        self.keyframe_constraints_reader = KeyframeConstraintReader(activate_coordinate_transform, scale_factor)
        self.trajectory_constraints_reader = TrajectoryConstraintReader(activate_coordinate_transform, scale_factor)

    def read_from_dict(self, mg_input):
        self.mg_input_file = mg_input

        if self.activate_joint_mapping:
            input_string = self._apply_joint_mapping_on_string(json.dumps(mg_input))
            self.mg_input_file = json.loads(input_string)

        success = self._verify_input()

        if success:
            if OUTPUT_MODE_KEY in list(mg_input.keys()) and mg_input[OUTPUT_MODE_KEY] == "Unity":
                self._set_orientation_to_null()

            self._extract_elementary_actions()
        return success

    def _extract_elementary_actions(self):
        if ACTIONS_KEY in self.mg_input_file.keys():
            self.action_list = self.mg_input_file[ACTIONS_KEY]
        elif TASKS_KEY in self.mg_input_file.keys():
            self.action_list = []
            for task in self.mg_input_file[TASKS_KEY]:
                if ACTIONS_KEY in task.keys():
                    self.action_list += task[ACTIONS_KEY]
        self.keyframe_annotations = self._extract_keyframe_annotations()

    def get_number_of_actions(self):
        return len(self.action_list)

    def get_session_id(self):
        if SESSION_KEY not in list(self.mg_input_file.keys()):
            return ""
        return self.mg_input_file[SESSION_KEY]

    def get_group_id(self):
        if GROUP_KEY not in list(self.mg_input_file.keys()):
            return ""
        return self.mg_input_file[GROUP_KEY]

    def get_start_pose(self):
        start_pose = dict()
        if None in self.mg_input_file[START_KEY][O_KEY]:
            start_pose[O_KEY] = None
        else:
            start_pose[O_KEY] = _transform_point_from_cad_to_opengl_cs(self.mg_input_file[START_KEY][O_KEY], self.activate_coordinate_transform)
        start_pose[P_KEY] = _transform_point_from_cad_to_opengl_cs(self.mg_input_file[START_KEY][P_KEY], self.activate_coordinate_transform)
        return start_pose

    def get_elementary_action_name(self, action_index):
        return self.action_list[action_index][ACTION_KEY]

    def _fill_joint_name_map(self):
        # TODO: read from file
        self.joint_name_map["RightHand"] = "RightToolEndSite"
        self.joint_name_map["LeftHand"] = "LeftToolEndSite"
        self.inverse_joint_name_map["RightToolEndSite"] = "RightHand"
        self.inverse_joint_name_map["LeftToolEndSite"] = "LeftHand"

    def _apply_joint_mapping_on_string(self, input_string):
        for key in list(self.joint_name_map.keys()):
            input_string = input_string.replace(key, self.joint_name_map[key])
        return input_string

    def inverse_map_joint(self, joint_name):
        if self.activate_joint_mapping and joint_name in list(self.inverse_joint_name_map.keys()):
            return self.inverse_joint_name_map[joint_name]
        else:
            return joint_name

    def _verify_input(self):
        success = True
        error_string = ""
        if ACTIONS_KEY not in list(self.mg_input_file.keys()) and TASKS_KEY not in list(self.mg_input_file.keys()):
            error_string = "Error: Did not find expected keys in the input data."
            success = False

        if ACTIONS_KEY in list(self.mg_input_file.keys()):
            for action in self.mg_input_file[ACTIONS_KEY]:
                action_name = action[ACTION_KEY]
                if action_name not in list(self.motion_state_graph.node_groups.keys()):
                    error_string = "Error: Unknown action " + action_name
                    success = False

                action_type = self.motion_state_graph.node_groups[action_name].get_action_type()
                if action_type == "locomotion" and len(action[CONSTRAINTS_KEY]) < 1:
                    error_string = "Error: A trajectory constraint needs to be specified for the locomotion action " + action_name
                    success = False

        write_message_to_log(error_string, LOG_MODE_ERROR)
        return success

    def _set_orientation_to_null(self):
        if ESTIMATE_ORIENTATION_KEY in list(self.mg_input_file.keys()) and \
                self.mg_input_file[ESTIMATE_ORIENTATION_KEY]:
            self.mg_input_file[START_KEY][O_KEY] = [None, None, None]

        for action in self.mg_input_file[ACTIONS_KEY]:
            for constraint in action[CONSTRAINTS_KEY]:
                for p in constraint[TRAJECTORY_CONSTRAINTS_KEY]:
                    if O_KEY not in list(p.keys()) or len(p[O_KEY]) == 0:
                        p[O_KEY] = [None, None, None]

    def center_constraints(self):
        start_pose = self.get_start_pose()
        offset = np.array(start_pose[P_KEY])
        if TASKS_KEY in self.mg_input_file:
            for task in self.mg_input_file[TASKS_KEY]:
                for action in task[ACTIONS_KEY]:
                    self.translate_action_constraints(action, offset)
        else:
            for action in self.mg_input_file[ACTIONS_KEY]:
                self.translate_action_constraints(action, offset)

        self.mg_input_file[START_KEY][P_KEY] = [0, 0, 0]
        return offset

    def translate_action_constraints(self, action, offset):
        for constraint in action[CONSTRAINTS_KEY]:
            if KEYFRAME_CONSTRAINTS_KEY in list(constraint.keys()):
                for p in constraint[KEYFRAME_CONSTRAINTS_KEY]:
                    new_p = p[P_KEY] - offset
                    p[P_KEY] = new_p.tolist()

            if TRAJECTORY_CONSTRAINTS_KEY in list(constraint.keys()):
                for p in constraint[TRAJECTORY_CONSTRAINTS_KEY]:
                    new_p = copy(p[P_KEY])
                    for idx, v in enumerate(new_p):
                        if v is not None:
                            new_p[idx] -= offset[idx]
                    p[P_KEY] = new_p

    def extract_trajectory_desc(self, action_index, joint_name, distance_treshold=-1):
        return self.trajectory_constraints_reader.extract_trajectory_desc(self.action_list, action_index, joint_name, distance_treshold)

    def get_ordered_keyframe_constraints(self, action_index, node_group):
        """
        Returns
        -------
            reordered_constraints: dict of lists
            dict of constraints lists applicable to a specific motion primitive of the node_group
        """
        return self.keyframe_constraints_reader.get_ordered_keyframe_constraints(self.action_list, action_index, node_group)

    def _extract_keyframe_annotations(self):
        """
        Returns
        ------
        * keyframe_annotations : a list of dicts
          Contains for every elementary action a dict that associates of events/actions with certain keyframes
        """
        keyframe_annotations = []
        for action_index, entry in enumerate(self.action_list):
            keyframe_annotations.append(self.get_keyframe_annotations(action_index))
        return keyframe_annotations

    def get_keyframe_annotations(self, action_index):
        """
        Returns
        ------
        * keyframe_annotations : a list of dicts
          Contains for every elementary action a dict that associates of events/actions with certain keyframes
        """
        annotations = dict()
        if ANNOTATIONS_KEY in self.action_list[action_index].keys():
            for annotation in self.action_list[action_index][ANNOTATIONS_KEY]:
                keyframe_label = annotation[KEYFRAME_KEY]
                annotations[keyframe_label] = annotation
        return annotations
